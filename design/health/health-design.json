{"updates":{"encrypt":"function (doc, req) {\n      /*\n        *  jsaes version 0.1  -  Copyright 2006 B. Poettering\n        *\n        *  This program is free software; you can redistribute it and/or\n        *  modify it under the terms of the GNU General Public License as\n        *  published by the Free Software Foundation; either version 2 of the\n        *  License, or (at your option) any later version.\n        *\n        *  This program is distributed in the hope that it will be useful,\n        *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n        *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n        *  General Public License for more details.\n        *\n        *  You should have received a copy of the GNU General Public License\n        *  along with this program; if not, write to the Free Software\n        *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n        *  02111-1307 USA\n        */\n\n      /*\n        * http://point-at-infinity.org/jsaes/\n        *\n        * This is a javascript implementation of the AES block cipher. Key lengths\n        * of 128, 192 and 256 bits are supported.\n        *\n        * The well-functioning of the encryption/decryption routines has been\n        * verified for different key lengths with the test vectors given in\n        * FIPS-197, Appendix C.\n        *\n        * The following code example enciphers the plaintext block '00 11 22 .. EE FF'\n        * with the 256 bit key '00 01 02 .. 1E 1F'.\n        *\n        *    AES_Init();\n        *\n        *    var block = new Array(16);\n        *    for(var i = 0; i < 16; i++)\n        *        block[i] = 0x11 * i;\n        *\n        *    var key = new Array(32);\n        *    for(var i = 0; i < 32; i++)\n        *        key[i] = i;\n        *\n        *    AES_ExpandKey(key);\n        *    AES_Encrypt(block, key);\n        *\n        *    AES_Done();\n        *\n        * Report bugs to: jsaes AT point-at-infinity.org\n        *\n        */\n\n      /******************************************************************************/\n\n      /*\n        AES_Init: initialize the tables needed at runtime. Call this function\n        before the (first) key expansion.\n        */\n\n      function AES_Init() {\n        AES_Sbox_Inv = new Array(256);\n        for(var i = 0; i < 256; i++)\n          AES_Sbox_Inv[AES_Sbox[i]] = i;\n\n        AES_ShiftRowTab_Inv = new Array(16);\n        for(var i = 0; i < 16; i++)\n          AES_ShiftRowTab_Inv[AES_ShiftRowTab[i]] = i;\n\n        AES_xtime = new Array(256);\n        for(var i = 0; i < 128; i++) {\n          AES_xtime[i] = i << 1;\n          AES_xtime[128 + i] = (i << 1) ^ 0x1b;\n        }\n      }\n\n      /*\n        AES_Done: release memory reserved by AES_Init. Call this function after\n        the last encryption/decryption operation.\n        */\n\n      function AES_Done() {\n        delete AES_Sbox_Inv;\n        delete AES_ShiftRowTab_Inv;\n        delete AES_xtime;\n      }\n\n      /*\n        AES_ExpandKey: expand a cipher key. Depending on the desired encryption\n        strength of 128, 192 or 256 bits 'key' has to be a byte array of length\n        16, 24 or 32, respectively. The key expansion is done \"in place\", meaning\n        that the array 'key' is modified.\n        */\n\n      function AES_ExpandKey(key) {\n        var kl = key.length, ks, Rcon = 1;\n        switch (kl) {\n          case 16: ks = 16 * (10 + 1); break;\n          case 24: ks = 16 * (12 + 1); break;\n          case 32: ks = 16 * (14 + 1); break;\n          default:\n            alert(\"AES_ExpandKey: Only key lengths of 16, 24 or 32 bytes allowed!\");\n        }\n        for(var i = kl; i < ks; i += 4) {\n          var temp = key.slice(i - 4, i);\n          if (i % kl == 0) {\n            temp = new Array(AES_Sbox[temp[1]] ^ Rcon, AES_Sbox[temp[2]],\n        AES_Sbox[temp[3]], AES_Sbox[temp[0]]);\n            if ((Rcon <<= 1) >= 256)\n        Rcon ^= 0x11b;\n          }\n          else if ((kl > 24) && (i % kl == 16))\n            temp = new Array(AES_Sbox[temp[0]], AES_Sbox[temp[1]],\n        AES_Sbox[temp[2]], AES_Sbox[temp[3]]);\n          for(var j = 0; j < 4; j++)\n            key[i + j] = key[i + j - kl] ^ temp[j];\n        }\n      }\n\n      /*\n        AES_Encrypt: encrypt the 16 byte array 'block' with the previously\n        expanded key 'key'.\n        */\n\n      function AES_Encrypt(block, key) {\n        var l = key.length;\n        AES_AddRoundKey(block, key.slice(0, 16));\n        for(var i = 16; i < l - 16; i += 16) {\n          AES_SubBytes(block, AES_Sbox);\n          AES_ShiftRows(block, AES_ShiftRowTab);\n          AES_MixColumns(block);\n          AES_AddRoundKey(block, key.slice(i, i + 16));\n        }\n        AES_SubBytes(block, AES_Sbox);\n        AES_ShiftRows(block, AES_ShiftRowTab);\n        AES_AddRoundKey(block, key.slice(i, l));\n      }\n\n      /*\n        AES_Decrypt: decrypt the 16 byte array 'block' with the previously\n        expanded key 'key'.\n        */\n\n      function AES_Decrypt(block, key) {\n        var l = key.length;\n        AES_AddRoundKey(block, key.slice(l - 16, l));\n        AES_ShiftRows(block, AES_ShiftRowTab_Inv);\n        AES_SubBytes(block, AES_Sbox_Inv);\n        for(var i = l - 32; i >= 16; i -= 16) {\n          AES_AddRoundKey(block, key.slice(i, i + 16));\n          AES_MixColumns_Inv(block);\n          AES_ShiftRows(block, AES_ShiftRowTab_Inv);\n          AES_SubBytes(block, AES_Sbox_Inv);\n        }\n        AES_AddRoundKey(block, key.slice(0, 16));\n      }\n\n      /******************************************************************************/\n\n      /* The following lookup tables and functions are for internal use only! */\n\n      AES_Sbox = new Array(99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,\n        118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,\n        147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,\n        7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,\n        47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,\n        251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,\n        188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,\n        100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,\n        50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,\n        78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,\n        116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,\n        158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,\n        137,13,191,230,66,104,65,153,45,15,176,84,187,22);\n\n      AES_ShiftRowTab = new Array(0,5,10,15,4,9,14,3,8,13,2,7,12,1,6,11);\n\n      function AES_SubBytes(state, sbox) {\n        for(var i = 0; i < 16; i++)\n          state[i] = sbox[state[i]];\n      }\n\n      function AES_AddRoundKey(state, rkey) {\n        for(var i = 0; i < 16; i++)\n          state[i] ^= rkey[i];\n      }\n\n      function AES_ShiftRows(state, shifttab) {\n        var h = new Array().concat(state);\n        for(var i = 0; i < 16; i++)\n          state[i] = h[shifttab[i]];\n      }\n\n      function AES_MixColumns(state) {\n        for(var i = 0; i < 16; i += 4) {\n          var s0 = state[i + 0], s1 = state[i + 1];\n          var s2 = state[i + 2], s3 = state[i + 3];\n          var h = s0 ^ s1 ^ s2 ^ s3;\n          state[i + 0] ^= h ^ AES_xtime[s0 ^ s1];\n          state[i + 1] ^= h ^ AES_xtime[s1 ^ s2];\n          state[i + 2] ^= h ^ AES_xtime[s2 ^ s3];\n          state[i + 3] ^= h ^ AES_xtime[s3 ^ s0];\n        }\n      }\n\n      function AES_MixColumns_Inv(state) {\n        for(var i = 0; i < 16; i += 4) {\n          var s0 = state[i + 0], s1 = state[i + 1];\n          var s2 = state[i + 2], s3 = state[i + 3];\n          var h = s0 ^ s1 ^ s2 ^ s3;\n          var xh = AES_xtime[h];\n          var h1 = AES_xtime[AES_xtime[xh ^ s0 ^ s2]] ^ h;\n          var h2 = AES_xtime[AES_xtime[xh ^ s1 ^ s3]] ^ h;\n          state[i + 0] ^= h1 ^ AES_xtime[s0 ^ s1];\n          state[i + 1] ^= h2 ^ AES_xtime[s1 ^ s2];\n          state[i + 2] ^= h1 ^ AES_xtime[s2 ^ s3];\n          state[i + 3] ^= h2 ^ AES_xtime[s3 ^ s0];\n        }\n      }\n\n      // START DESIGN DOC\n\n      var request = JSON.parse(req.body);\n      var block = Object.keys(request).reduce(function(b, k) {\n        if (k !== 'id' && k !== 'key') {\n          b[k] = request[k];\n        }\n        return b;\n      }, {});\n      var reqKey = request.key;\n      // return [ null, JSON.stringify(block) + JSON.stringify(request) ];\n      AES_Init();\n      AES_ExpandKey(reqKey);\n      AES_Encrypt(block, reqKey);\n      AES_Done();\n\n      return [ { '_id': request.id, 'block': block }, block ];\n\n    }"}}